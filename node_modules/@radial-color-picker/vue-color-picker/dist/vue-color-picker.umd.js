(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.VueColorPicker = factory());
}(this, (function () { 'use strict';

  /**
   * radial-color-picker/color-wheel v2.2.2
   *
   * https://github.com/radial-color-picker/color-wheel
   *
   * Copyright (c) 2018-present, Rosen Kanev
   * Released under the MIT License.
   */
  /**
   * Modified version of Lea Verou's
   * {@link https://github.com/leaverou/conic-gradient conic-gradient}.
   *
   * @example
   * paintColorWheelToCanvas(document.querySelector('#canvas'), 250);
   *
   * @param   {HTMLCanvasElement} canvas Canvas to paint the color wheel
   * @param   {Number}            size   Color wheel radius in pixels
   * @returns {HTMLCanvasElement} canvas The passed canvas for easier chaining
   */
  function paintColorWheelToCanvas(canvas, size) {
    const half = size / 2;
    const radius = Math.sqrt(2) * half;
    const deg = Math.PI / 180;
    const pi2 = Math.PI * 2;
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d'); // .02: To prevent empty blank line and corresponding moire
    // only non-alpha colors are cared now

    const thetaOffset = 0.5 * deg + 0.02; // Transform coordinate system so that angles start from the top left, like in CSS

    ctx.translate(half, half);
    ctx.rotate(-Math.PI / 2);
    ctx.translate(-half, -half);

    for (let i = 0; i < 360; i += 0.5) {
      ctx.fillStyle = "hsl(" + i + ", 100%, 50%)";
      ctx.beginPath();
      ctx.moveTo(half, half);
      const beginArg = i * deg;
      const endArg = Math.min(pi2, beginArg + thetaOffset);
      ctx.arc(half, half, radius, beginArg, endArg);
      ctx.closePath();
      ctx.fill();
    }

    return canvas;
  }

  /**
   * radial-color-picker/rotator v3.0.1
   *
   * https://github.com/radial-color-picker/rotator
   *
   * Copyright (c) 2018-present, Rosen Kanev
   * Released under the MIT License.
   */
  const TO_DEGREES = 180 / Math.PI;
  const normalizeAngle = angle => {
    const mod = angle % 360;
    return mod < 0 ? 360 + mod : mod;
  };
  const getRotationFromCoords = ({
    x,
    y
  }, rect) => {
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    return Math.atan2(y - cy, x - cx) * TO_DEGREES;
  };
  const noop = () => {};

  /**
   * Modified version of Denis Radin's
   * {@link https://github.com/PixelsCommander/Propeller Propeller}.
   */

  class Rotator {
    constructor(element, options) {
      this.active = false;
      this.element = element;
      this.element.style.willChange = 'transform';
      this.initOptions(options);
      this.updateCSS();
      this.bindHandlers();
      this.addListeners();
    }

    get angle() {
      return this._angle;
    }

    set angle(value) {
      if (this._angle !== value) {
        this._angle = normalizeAngle(value);
        this.updateCSS();
      }
    }

    initOptions(options) {
      options = options || {};
      this.onRotate = options.onRotate || noop;
      this.onDragStart = options.onDragStart || noop;
      this.onDragStop = options.onDragStop || noop;
      this._angle = options.angle || 0;
    }

    bindHandlers() {
      this.onRotationStart = this.onRotationStart.bind(this);
      this.onRotated = this.onRotated.bind(this);
      this.onRotationStop = this.onRotationStop.bind(this);
    }

    addListeners() {
      this.element.addEventListener('touchstart', this.onRotationStart, {
        passive: true
      });
      document.addEventListener('touchmove', this.onRotated, {
        passive: false
      });
      document.addEventListener('touchend', this.onRotationStop, {
        passive: true
      });
      document.addEventListener('touchcancel', this.onRotationStop, {
        passive: true
      });
      this.element.addEventListener('mousedown', this.onRotationStart, {
        passive: true
      });
      document.addEventListener('mousemove', this.onRotated, {
        passive: false
      });
      document.addEventListener('mouseup', this.onRotationStop, {
        passive: true
      });
      document.addEventListener('mouseleave', this.onRotationStop, {
        passive: false
      });
    }

    removeListeners() {
      this.element.removeEventListener('touchstart', this.onRotationStart);
      document.removeEventListener('touchmove', this.onRotated);
      document.removeEventListener('touchend', this.onRotationStop);
      document.removeEventListener('touchcancel', this.onRotationStop);
      this.element.removeEventListener('mousedown', this.onRotationStart);
      document.removeEventListener('mousemove', this.onRotated);
      document.removeEventListener('mouseup', this.onRotationStop);
      document.removeEventListener('mouseleave', this.onRotationStop);
    }

    destroy() {
      this.onRotationStop();
      this.removeListeners();
    }

    onRotationStart(event) {
      if (event.type === 'touchstart' || event.button === 0) {
        this.active = true;
        this.onDragStart(event);
        this.setAngleFromEvent(event);
      }
    }

    onRotationStop() {
      if (this.active) {
        this.active = false;
        this.onDragStop();
      }

      this.active = false;
    }

    onRotated(event) {
      if (this.active) {
        event.preventDefault();
        this.setAngleFromEvent(event);
      }
    }

    setAngleFromEvent(event) {
      const ev = event.targetTouches ? event.targetTouches[0] : event;
      const newAngle = getRotationFromCoords({
        x: ev.clientX,
        y: ev.clientY
      }, this.element.getBoundingClientRect()); // atan2 gives values between -180 to 180 deg
      // add 90 degrees offset so that it starts from 0 deg (or red)
      // and then normalize negative values

      this._angle = normalizeAngle(newAngle + 90);
      this.updateCSS();
      this.onRotate(this._angle);
    }

    updateCSS() {
      this.element.style.transform = "rotate(" + this._angle + "deg)";
    }

  }

  //
  const colors = ['red', 'yellow', 'green', 'cyan', 'blue', 'magenta', 'red'];
  const keys = {
    ArrowUp: (oldAngle, step) => oldAngle + step,
    ArrowRight: (oldAngle, step) => oldAngle + step,
    ArrowDown: (oldAngle, step) => oldAngle - step,
    ArrowLeft: (oldAngle, step) => oldAngle - step,
    PageUp: (oldAngle, step) => oldAngle + step * 10,
    PageDown: (oldAngle, step) => oldAngle - step * 10,
    Home: () => 0,
    End: () => 359
  };
  var script = {
    rcp: null,
    name: 'ColorPicker',
    props: {
      hue: {
        default: 0
      },
      saturation: {
        default: 100
      },
      luminosity: {
        default: 50
      },
      alpha: {
        default: 1
      },
      step: {
        default: 1
      },
      mouseScroll: {
        default: false
      },
      variant: {
        default: 'collapsible' // collapsible | persistent

      },
      disabled: {
        default: false
      },
      initiallyCollapsed: {
        default: false
      },
      ariaLabel: {
        default: 'color picker'
      },
      ariaRoledescription: {
        default: 'radial slider'
      },
      ariaValuetext: {
        default: ''
      },
      ariaLabelColorWell: {
        default: 'color well'
      }
    },

    data() {
      return {
        angle: 0,
        ssrHue: 0,
        isPaletteIn: !this.initiallyCollapsed,
        isKnobIn: !this.initiallyCollapsed,
        isPressed: false,
        isRippling: false,
        isDragging: false
      };
    },

    computed: {
      color() {
        return `hsla(${this.angle}, ${this.saturation}%, ${this.luminosity}%, ${this.alpha})`;
      },

      valuetext() {
        return colors[Math.round(this.angle / 60)];
      }

    },
    watch: {
      hue: function (angle) {
        this.angle = angle;
        this.rcp.angle = angle;
      }
    },

    created() {
      // update the SSR value once when the component is created
      // prevents knob jumping when using Server Side Rendering
      // where the knob's position is updated only after the client-side code is executed (on mount)
      this.ssrHue = this.hue;
      this.angle = this.ssrHue;
    },

    mounted() {
      // ignore testing code that will be removed by dead code elimination for production

      /* istanbul ignore next */
      if ( this.initiallyCollapsed && this.variant === 'persistent') {
        console.warn(`Incorrect config: using variant="persistent" and :initiallyCollapsed="true" at the same time is not supported.`);
      }

      const isConicGradientSupported = getComputedStyle(this.$refs.palette).backgroundImage.includes('conic'); // ignore conic-gradient support & polyfill

      /* istanbul ignore else */

      if (!isConicGradientSupported) {
        paintColorWheelToCanvas(this.$refs.palette.firstElementChild, this.$el.offsetWidth || 280);
      }

      this.rcp = new Rotator(this.$refs.rotator, {
        angle: this.angle,
        onRotate: hue => {
          this.angle = hue;
          this.$emit('input', this.angle);
        },
        onDragStart: () => {
          this.isDragging = true;
        },
        onDragStop: () => {
          this.isDragging = false;
          this.$emit('change', this.angle);
        }
      });
    },

    methods: {
      onKeyDown(ev) {
        if (this.disabled || this.isPressed || !this.isKnobIn || !(ev.key in keys)) return;
        ev.preventDefault();
        this.rcp.angle = keys[ev.key](this.rcp.angle, this.step);
        this.angle = this.rcp.angle;
        this.$emit('input', this.angle);
        this.$emit('change', this.angle);
      },

      onScroll(ev) {
        if (this.isPressed || !this.isKnobIn) return;
        ev.preventDefault();

        if (ev.deltaY > 0) {
          this.rcp.angle += this.step;
        } else {
          this.rcp.angle -= this.step;
        }

        this.angle = this.rcp.angle;
        this.$emit('input', this.angle);
        this.$emit('change', this.angle);
      },

      selectColor() {
        this.isPressed = true;

        if (this.isPaletteIn && this.isKnobIn) {
          this.$emit('select', this.angle);
          this.isRippling = true;
        } else {
          this.isPaletteIn = true;
        }
      },

      togglePicker() {
        if (this.variant !== 'persistent') {
          if (this.isKnobIn) {
            this.isKnobIn = false;
          } else {
            this.isKnobIn = true;
            this.isPaletteIn = true;
          }
        }

        this.isRippling = false;
        this.isPressed = false;
      },

      hidePalette() {
        if (!this.isKnobIn) {
          this.isPaletteIn = false;
        }
      }

    },

    beforeDestroy() {
      this.rcp.destroy();
      this.rcp = null;
    }

  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
      }
      // Vue.extend constructor export interop.
      const options = typeof script === 'function' ? script.options : script;
      // render functions
      if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          // functional template
          if (isFunctionalTemplate) {
              options.functional = true;
          }
      }
      // scopedId
      if (scopeId) {
          options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
          // server build
          hook = function (context) {
              // 2.3 injection
              context =
                  context || // cached call
                      (this.$vnode && this.$vnode.ssrContext) || // stateful
                      (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
              // 2.2 with runInNewContext: true
              if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                  context = __VUE_SSR_CONTEXT__;
              }
              // inject component styles
              if (style) {
                  style.call(this, createInjectorSSR(context));
              }
              // register component module identifier for async chunk inference
              if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
              }
          };
          // used by ssr in case component is cached and beforeCreate
          // never gets called
          options._ssrRegister = hook;
      }
      else if (style) {
          hook = shadowMode
              ? function (context) {
                  style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
              }
              : function (context) {
                  style.call(this, createInjector(context));
              };
      }
      if (hook) {
          if (options.functional) {
              // register for functional component in vue file
              const originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
              };
          }
          else {
              // inject component registration as beforeCreate hook
              const existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
      }
      return script;
  }

  /* script */
  const __vue_script__ = script;
  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "rcp",
        class: { dragging: _vm.isDragging, disabled: _vm.disabled },
        attrs: {
          role: "slider",
          "aria-roledescription": _vm.ariaRoledescription,
          "aria-label": _vm.ariaLabel,
          "aria-expanded": _vm.isPaletteIn ? "true" : "false",
          "aria-valuemin": "0",
          "aria-valuemax": "359",
          "aria-valuenow": _vm.angle,
          "aria-valuetext": _vm.ariaValuetext || _vm.valuetext,
          "aria-disabled": _vm.disabled ? "true" : "false",
          tabindex: _vm.disabled ? -1 : 0
        },
        on: {
          keyup: function($event) {
            if (
              !$event.type.indexOf("key") &&
              _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
            ) {
              return null
            }
            return _vm.selectColor($event)
          },
          keydown: _vm.onKeyDown
        }
      },
      [
        _c(
          "div",
          {
            ref: "palette",
            staticClass: "rcp__palette",
            class: _vm.isPaletteIn ? "in" : "out"
          },
          [_c("canvas")]
        ),
        _vm._v(" "),
        _c(
          "div",
          _vm._g(
            {
              ref: "rotator",
              staticClass: "rcp__rotator",
              style: {
                "pointer-events":
                  _vm.disabled || _vm.isPressed || !_vm.isKnobIn ? "none" : null,
                transform: "rotate(" + _vm.ssrHue + "deg)"
              }
            },
            _vm.mouseScroll ? { wheel: _vm.onScroll } : null
          ),
          [
            _c("div", {
              staticClass: "rcp__knob",
              class: _vm.isKnobIn ? "in" : "out",
              on: { transitionend: _vm.hidePalette }
            })
          ]
        ),
        _vm._v(" "),
        _c("div", {
          staticClass: "rcp__ripple",
          class: { rippling: _vm.isRippling },
          style: { borderColor: _vm.color }
        }),
        _vm._v(" "),
        _c("button", {
          staticClass: "rcp__well",
          class: { pressed: _vm.isPressed },
          style: { backgroundColor: _vm.color },
          attrs: {
            type: "button",
            "aria-label": _vm.ariaLabelColorWell,
            disabled: _vm.disabled,
            tabindex: _vm.disabled ? -1 : 0
          },
          on: { animationend: _vm.togglePicker, click: _vm.selectColor }
        })
      ]
    )
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = undefined;
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    
    /* style inject shadow dom */
    

    
    const __vue_component__ = normalizeComponent(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      false,
      undefined,
      undefined,
      undefined
    );

  __vue_component__.install = function (Vue) {
    Vue.component('ColorPicker', __vue_component__);
  };

  return __vue_component__;

})));
